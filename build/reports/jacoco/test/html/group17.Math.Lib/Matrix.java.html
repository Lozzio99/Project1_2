<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Matrix.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Project_1.2</a> &gt; <a href="index.source.html" class="el_package">group17.Math.Lib</a> &gt; <span class="el_source">Matrix.java</span></div><h1>Matrix.java</h1><pre class="source lang-java linenums">package group17.Math.Lib;

import group17.Interfaces.Vector3dInterface;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import java.io.Serializable;
import java.util.Arrays;

import static java.lang.System.arraycopy;

/**
 * The type Matrix.
 */
public class Matrix implements Serializable {
    /**
     * The N rows.
     */
    public int n_rows;
    /**
     * The N cols.
     */
    public int n_cols;
    /**
     * The Matrix.
     */
    public double[][] matrix;


    /**
     * Constructor from array
     *
     * @param matrix the double dimensions array Construct a matrix with the given values
     */
<span class="nc" id="L35">    public Matrix(double[][] matrix) {</span>
<span class="nc" id="L36">        this.n_rows = matrix.length;</span>
<span class="nc" id="L37">        this.n_cols = matrix[0].length;</span>
<span class="nc" id="L38">        this.matrix = matrix;</span>
<span class="nc" id="L39">    }</span>

    /**
     * static method for the matrix multiplication
     *
     * @param A the left side matrix
     * @param B the right side matrix
     * @return the product from the two in a matrix
     */
    @Contract(&quot;_, _ -&gt; new&quot;)
    public static @NotNull Matrix multiply(Matrix A, Matrix B) {
<span class="nc bnc" id="L50" title="All 2 branches missed.">        if (A.n_cols != B.n_rows)</span>
<span class="nc" id="L51">            throw new IllegalArgumentException(&quot;Columns of A and rows  and B must have same dimensions!&quot;);</span>

<span class="nc" id="L53">        double[][] res = new double[A.n_rows][B.n_cols];</span>
<span class="nc bnc" id="L54" title="All 2 branches missed.">        for (int i = 0; i &lt; A.n_rows; i++) {</span>
<span class="nc bnc" id="L55" title="All 2 branches missed.">            for (int j = 0; j &lt; B.n_cols; j++) {</span>
<span class="nc" id="L56">                double sum = 0;</span>
<span class="nc bnc" id="L57" title="All 2 branches missed.">                for (int k = 0; k &lt; A.n_cols; k++) {</span>
<span class="nc" id="L58">                    sum += A.getMatrix()[i][k] * B.getMatrix()[k][j];</span>
                }
<span class="nc" id="L60">                res[i][j] = sum;</span>
            }
        }
<span class="nc" id="L63">        return new Matrix(res);</span>
    }

    /**
     * Invert double [ ] [ ].
     *
     * @param in the in
     * @return the double [ ] [ ]
     */
    public static double[][] invert(double[][] in) {
<span class="nc" id="L73">        double[][] a = new double[in.length][in[0].length];</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">        for (int i = 0; i &lt; in.length; i++) {</span>
<span class="nc" id="L75">            arraycopy(in[i],</span>
                    0,
                    a[i],
                    0,
                    in[0].length);
        }
<span class="nc" id="L81">        int N = a.length;</span>

<span class="nc" id="L83">        double[][] inverse = new double[N][N], b = new double[N][N];</span>
<span class="nc" id="L84">        int[] indexes = new int[N];</span>

<span class="nc bnc" id="L86" title="All 2 branches missed.">        for (int x = 0; x &lt; N; x++) b[x][x] = 1;</span>
<span class="nc" id="L87">        gaussian(a, indexes); // Transform the matrix into an upper triangle</span>
        // Update the matrix b[v][u] with the ratios stored
<span class="nc bnc" id="L89" title="All 2 branches missed.">        for (int v = 0; v &lt; N - 1; v++)</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">            for (int u = v + 1; u &lt; N; u++)</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">                for (int w = 0; w &lt; N; w++) {</span>
<span class="nc" id="L92">                    b[indexes[u]][w] -= a[indexes[u]][v] * b[indexes[v]][w];</span>
                }

<span class="nc bnc" id="L95" title="All 2 branches missed.">        for (int k = 0; k &lt; N; k++) {</span>
<span class="nc" id="L96">            inverse[N - 1][k] = (b[indexes[N - 1]][k]) / (a[indexes[N - 1]][N - 1]);</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">            for (int j = N - 2; j &gt;= 0; j--) {</span>
<span class="nc" id="L98">                inverse[j][k] = b[indexes[j]][k];        // Perform backward substitutions</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">                for (int l = j + 1; l &lt; N; l++) {</span>
<span class="nc" id="L100">                    inverse[j][k] -= a[indexes[j]][l] * inverse[l][k];</span>
                }
<span class="nc" id="L102">                inverse[j][k] /= a[indexes[j]][j];</span>
            }
        }
<span class="nc" id="L105">        return inverse;</span>
    }

    /**
     * Gaussian.
     *
     * @param m     the matrix
     * @param index the index
     */
    public static void gaussian(double[][] m, int[] index) {
<span class="nc" id="L115">        int n = index.length;</span>
<span class="nc" id="L116">        double[] c = new double[n];</span>

        // Initialize the index
<span class="nc bnc" id="L119" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i)</span>
<span class="nc" id="L120">            index[i] = i;</span>

        // Find the rescaling factors, one from each row
<span class="nc bnc" id="L123" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L124">            double c1 = 0;</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">            for (int j = 0; j &lt; n; ++j) {</span>
<span class="nc" id="L126">                double c0 = Math.abs(m[i][j]);</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">                if (c0 &gt; c1) c1 = c0;</span>
            }
<span class="nc" id="L129">            c[i] = c1;</span>
        }

        // Search the pivoting element from each column
<span class="nc" id="L133">        int k = 0;</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">        for (int j = 0; j &lt; n - 1; ++j) {</span>
<span class="nc" id="L135">            double pi1 = 0;</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">            for (int i = j; i &lt; n; ++i) {</span>
<span class="nc" id="L137">                double pi0 = Math.abs(m[index[i]][j]);</span>
<span class="nc" id="L138">                pi0 /= c[index[i]];</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">                if (pi0 &gt; pi1) {</span>
<span class="nc" id="L140">                    pi1 = pi0;</span>
<span class="nc" id="L141">                    k = i;</span>
                }
            }

            // Interchange rows according to the pivoting order
<span class="nc" id="L146">            int itmp = index[j];</span>
<span class="nc" id="L147">            index[j] = index[k];</span>
<span class="nc" id="L148">            index[k] = itmp;</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">            for (int i = j + 1; i &lt; n; ++i) {</span>
<span class="nc" id="L150">                double pj = m[index[i]][j] / m[index[j]][j];</span>

                // Record pivoting ratios below the diagonal
<span class="nc" id="L153">                m[index[i]][j] = pj;</span>

                // Modify other elements accordingly
<span class="nc bnc" id="L156" title="All 2 branches missed.">                for (int l = j + 1; l &lt; n; ++l)</span>
<span class="nc" id="L157">                    m[index[i]][l] -= pj * m[index[j]][l];</span>
            }
        }
<span class="nc" id="L160">    }</span>
    /**
     * accessor method
     *
     * @return the matrix of this field
     */
    public double[][] getMatrix() {
<span class="nc" id="L167">        return this.matrix;</span>
    }

    /**
     * Instance method for matrix-vector multiplication
     *
     * @param v right side vector
     * @return vector as a result of product
     */
    public Vector3dInterface multiplyVector(Vector3dInterface v) {
<span class="nc" id="L177">        Matrix n = new Matrix(</span>
<span class="nc" id="L178">                new double[][]{{v.getX()}, {v.getY()}, {v.getZ()}}</span>
        );
<span class="nc" id="L180">        Matrix res = Matrix.multiply(new Matrix(matrix), n);</span>
<span class="nc" id="L181">        return new Vector3D(res.matrix[0][0], res.matrix[1][0], res.matrix[2][0]);</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L186">        StringBuilder s = new StringBuilder();</span>

<span class="nc bnc" id="L188" title="All 2 branches missed.">        for (double[] m : this.matrix) s.append(Arrays.toString(m)).append(&quot;\n&quot;);</span>

<span class="nc" id="L190">        return &quot;Matrix{ &quot; + n_rows +</span>
                &quot;x&quot; + n_cols +
<span class="nc" id="L192">                &quot;,\n&quot; + s.toString().trim() +</span>
                '}';
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>