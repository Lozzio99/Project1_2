<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ODESolverInterface.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Project_1.2</a> &gt; <a href="index.source.html" class="el_package">group17.Interfaces</a> &gt; <span class="el_source">ODESolverInterface.java</span></div><h1>ODESolverInterface.java</h1><pre class="source lang-java linenums">/*
 * @author Pieter Collins, Christof Seiler, Katerina Stankova, Nico Roos, Katharina Schueller
 * @version 0.99.0
 *
 * This interface serves as the API for students in phase 1.
 */

package group17.Interfaces;

import group17.Math.Lib.GravityFunction;

import static group17.Utils.Config.STEP_SIZE;


/**
 * A class for solving a general differential equation dy/dt = f(t,y)
 * y(t) describes the state of the system at time t
 * f(t,y(t)) defines the derivative of y(t) with respect to time t
 */
public interface ODESolverInterface {

    /**
     * Solve state interface [ ].
     *
     * @param f  the f
     * @param y0 the y 0
     * @param ts the ts
     * @return the state interface [ ]
     */
    /*
     * Solve the differential equation by taking multiple steps.
     *
     * @param   f       the function defining the differential equation dy/dt=f(t,y)
     * @param   y0      the starting state
     * @param   ts      the times at which the states should be output, with ts[0] being the initial time
     * @return  an array of size ts.length with all intermediate states along the path
     */
    default StateInterface[] solve(ODEFunctionInterface f, StateInterface y0, double[] ts) {
<span class="nc" id="L39">        StateInterface[] states = new StateInterface[ts.length];</span>
<span class="nc" id="L40">        double endTime = ts[ts.length - 1];</span>
<span class="nc" id="L41">        double currTime = ts[0];</span>

<span class="nc bnc" id="L43" title="All 2 branches missed.">        for (int i = 0; i &lt; ts.length - 1; i++) {</span>
<span class="nc" id="L44">            double h = ts[i + 1] - ts[i];</span>
<span class="nc" id="L45">            STEP_SIZE = h;</span>
<span class="nc" id="L46">            states[i] = this.step(f, currTime, y0, h);</span>
<span class="nc" id="L47">            y0 = states[i];</span>
<span class="nc" id="L48">            currTime += h;</span>
        }
<span class="nc" id="L50">        double h = ts[ts.length - 1] - ts[ts.length - 2];</span>
<span class="nc" id="L51">        states[states.length - 1] = y0.addMul(currTime, f.call(h, y0));</span>
<span class="nc" id="L52">        return states;</span>
    }

    /**
     * Solve state interface [ ].
     *
     * @param f  the f
     * @param y0 the y 0
     * @param tf the tf
     * @param h  the h
     * @return the state interface [ ]
     */
    /*
     * Solve the differential equation by taking multiple steps of equal size, starting at time 0.
     * The final step may have a smaller size, if the step-size does not exactly divide the solution time range
     *
     * @param   f       the function defining the differential equation dy/dt=f(t,y)
     * @param   y0      the starting state
     * @param   tf      the final time
     * @param   h       the size of step to be taken
     * @return  an array of size round(tf/h)+1 including all intermediate states along the path
     */
    default StateInterface[] solve(ODEFunctionInterface f, StateInterface y0, double tf, double h) {
<span class="nc" id="L75">        StateInterface[] path = new StateInterface[(int) (Math.round(tf / h)) + 2];</span>
<span class="nc" id="L76">        double currTime = 0;</span>
<span class="nc" id="L77">        path[0] = y0;</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">        for (int i = 1; i &lt; path.length - 1; i++) {</span>
<span class="nc" id="L79">            path[i] = this.step(f, currTime, y0, h);</span>
<span class="nc" id="L80">            y0 = path[i];</span>
<span class="nc" id="L81">            currTime += h;</span>
        }
<span class="nc" id="L83">        path[path.length - 1] = this.step(f, tf - currTime, y0, tf - currTime);</span>
<span class="nc" id="L84">        return path;</span>
    }

    /**
     * Step state interface.
     *
     * @param f the f
     * @param t the t
     * @param y the y
     * @param h the h
     * @return the state interface
     */
    /*
     * Update rule for one step.
     *
     * @param   f   the function defining the differential equation dy/dt=f(t,y)
     * @param   t   the time
     * @param   y   the state
     * @param   h   the step size
     * @return  the new state after taking one step
     */
    StateInterface step(ODEFunctionInterface f, double t, StateInterface y, double h);

    /**
     * For Higher CPU usages, should return MaxCPUSolver object
     * this is used to evaluate single bodies by individual threads,
     * therefore will be consequently implemented in different ways
     *
     * @return the function used for calculations
     * @see GravityFunction
     */
    ODEFunctionInterface getFunction();

    String toString();

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>